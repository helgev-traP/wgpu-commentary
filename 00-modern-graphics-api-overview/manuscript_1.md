# 現代グラフィックAPI概説

目次

- 各回のURL
- ...

- 今回の内容
  - GPUの動かし方
  - レンダリングの格段で行われていること、プログラマの仕事とGPUの仕事
  - グラフィックパイプラインのCPU側の操作

## GPUの動き方

### CPUとGPU

GPUは処理主体ではありません。GPU単体で処理はできず、必要なデータやリソース、コマンドをCPU側から送る必要があります。GPUが利用するデータやテクスチャ、シェーダーコード、パイプライン状態の設定などはすべて一度完全にグラフィックボードに
ここでいうCPU側・GPU側とは、

- CPU側
  CPU・メインメモリ・マザーボード
- GPU側
  GPU・VRAM・基盤とBIOS
  GPU側をすべてまとめて一般にグラフィックボードと呼びます。($GPU \in グラボ$)

のことです。この2つはPCIeを通して接続されます。PCIeでのデータ交換はGPU<->VRAMでのデータ交換よりもずっと、レイテンシの面でもスループットの面でも遅く、パフォーマンスに気を付けないと往々にしてPCIeがボトルネックとなります。この事実は後々レンダリングのパフォーマンス改善の回で思い出していただきます。
(ちなみに、CPUオンボードグラフィックを使用してる場合はメインメモリの中からVRAMとしていくらかの領域を割り当ててGPUに使わせます)

### グラフィックAPI規格

GPUは処理主体ではないのでCPUからPCIeを通してコマンドを送り続けないといけません。これはGPUベンダー(NVIDIA, AMD, Intel)が提供するドライバーが行います。それらのドライバーを利用できるようにするためのAPIがグラフィックAPIです。
昔(数十年前？)はGPUベンダー各社が独自のAPI規格を公開していたそうです。しかしそれではGPUごとにプログラムを組み直さなければならないため、統一規格が提案され、現代でのGPUプログラミング環境となっています。

現在使われているグラフィックAPI規格で、直接GPUを操作している(つまりドライバーが直接APIを提供する形の)ものは以下の4つです。

- DirectX 12 / DirectX 3D 12
  Windows上のAPIです。ゲーム向けにパフォーマンスチューニングするための機能が多く、
- Vulkan
  Windows/Linux上のAPIです。MacOSからもMoltenVKを間に挟むことで使えるようにできます。
- Metal
  MacOS/iOS上のAPIです。Appleでしか使えません。
- OpenGL
  クロスプラットフォームAPIです。DX12, Vulkan, Metalと比べ、古く、抽象化がレイヤーが分厚いAPIです。歴史が長いためCADなどの互換性が重視されるアプリで使われるそうですが、現在はDX12, Vulkan, Metalの方が主流です。Blenderも最近v4.5でVulkanに対応したことが話題になりましたね。

これらの規格をサポートするドライバーをGPUベンダーからインストールすることで、GPUを操作できるようになります。
また、以上のAPIをラッピングしたAPI規格として以下のものもあります。

- WebGL
  OpenGLをブラウザ上で実行できるようにしたAPIです。中身はOpenGLです。機能追加はこれ以上行われません。
- WebGPU
  WebGLの後継APIです。DirectX 12, Vulkan, Metalの最小公倍数的なAPIです。OpenGL/WebGLよりもずっと低レイヤーなAPIで、クロスプラットフォームです。通常バックエンドでDX12, Vulkan, Metal, OpenGLを動かす実装がされています。実行されたマシンの環境に応じて最適なバックエンドが選ばれます。

このブログシリーズではWebGPUの実装であるwgpuを扱います。WebGPUとwgpuについては次回で詳しく説明します。
また、今後このシリーズ内で単にAPIと書いたときはグラフィックAPIのことを指します。

## モデルをレンダリングするまでに行われること　プログラマの仕事とGPUの仕事

抽象度をだんだん下げながら順を追って説明します。

### ３Dモデルのレンダリングで処理したいこと

まず、CPU側で以下のコマンドを作成します。

1. まずGPUから利用するリソースをすべて準備・アップロードします。
   テクスチャや頂点データ、シェーダーコードやパイプラインを準備したり、コンパイルします。それらをアップロードします。
2. レンダリングパスをスタートさせ、パスにパイプラインやリソースを割り当てます。
3. ドローコールを発行し、GPUに描画を指示します。

コマンドを発行すると、GPUはそれを実行キューに追加し、順次実行していきます。wgpuではリソースはコマンド送信のタイミングで一緒に送信されます。
GPUはコマンドを受け取ると、以下の処理を行います。

- レンダリングパス
  1. コマンドの通りにリソースをバインドします。
  2. 頂点シェーダーを実行し、座標変換を行います。
  3. すべてのポリゴンについて、それが内包するすべてのピクセル位置にフラグメントを一つずつ生成します。
  4. 頂点シェーダーの出力をフラグメントに渡します。その際、ポリゴンの内部のフラグメントには線形補完された値が渡されます。
     一つのポリゴンについて、3つの頂点データのグラデーションとしてフラグメントに渡されます。
  5. フラグメントシェーダーを実行し、フラグメントの色を決定します。設定に応じて深度テストなどが行われます。
  6. 最終的なフラグメントをレンダリングターゲットの該当ピクセルにブレンドします。
- コンピュートパス
  1. コマンドの通りにリソースをバインドします。
  2. コンピュートシェーダーを実行し、GPU上で計算を行います。
     リソースの読み出し、書き込みはシェーダーコードが担います。
